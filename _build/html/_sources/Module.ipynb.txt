{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Modules\n",
    "\n",
    "## PostSolver.py"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "file for post HJB with k and y\n",
    "\"\"\"\n",
    "from datetime import datetime\n",
    "import time\n",
    "import petsclinearsystem\n",
    "from petsc4py import PETSc\n",
    "import petsc4py\n",
    "from src.Utility import finiteDiff_3D\n",
    "import SolveLinSys\n",
    "from supportfunctions import finiteDiff\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os\n",
    "import sys\n",
    "sys.path.append(\"../src/\")\n",
    "# from numba import njit\n",
    "\n",
    "\n",
    "\"\"\"\n",
    "solver.py\n",
    "For 3D abatement solver\n",
    "\"\"\"\n",
    "sys.path.append(\"../../src/\")\n",
    "\n",
    "\n",
    "def pde_one_interation(ksp, petsc_mat, X1_mat_1d, X2_mat_1d, X3_mat_1d, lowerLims, upperLims, dVec, increVec, v0, A, B_1, B_2, B_3, C_1, C_2, C_3, D, tol, epsilon):\n",
    "\n",
    "    bpoint1 = time.time()\n",
    "    A_1d = A.ravel(order='F')\n",
    "    C_1_1d = C_1.ravel(order='F')\n",
    "    C_2_1d = C_2.ravel(order='F')\n",
    "    C_3_1d = C_3.ravel(order='F')\n",
    "    B_1_1d = B_1.ravel(order='F')\n",
    "    B_2_1d = B_2.ravel(order='F')\n",
    "    B_3_1d = B_3.ravel(order='F')\n",
    "    D_1d = D.ravel(order='F')\n",
    "    v0_1d = v0.ravel(order='F')\n",
    "    petsclinearsystem.formLinearSystem(X1_mat_1d, X2_mat_1d, X3_mat_1d, A_1d, B_1_1d, B_2_1d,\n",
    "                                       B_3_1d, C_1_1d, C_2_1d, C_3_1d, epsilon, lowerLims, upperLims, dVec, increVec, petsc_mat)\n",
    "    b = v0_1d + D_1d * epsilon\n",
    "    petsc_rhs = PETSc.Vec().createWithArray(b)\n",
    "    x = petsc_mat.createVecRight()\n",
    "\n",
    "    # create linear solver\n",
    "    start_ksp = time.time()\n",
    "    ksp.setOperators(petsc_mat)\n",
    "    ksp.setTolerances(rtol=tol)\n",
    "    ksp.solve(petsc_rhs, x)\n",
    "    petsc_rhs.destroy()\n",
    "    x.destroy()\n",
    "    out_comp = np.array(ksp.getSolution()).reshape(A.shape, order=\"F\")\n",
    "    end_ksp = time.time()\n",
    "    num_iter = ksp.getIterationNumber()\n",
    "    return out_comp, end_ksp, bpoint1\n",
    "\n",
    "\n",
    "def _FOC_update(v0, steps=(), states=(), args=(), controls=(), fraction=0.5):\n",
    "\n",
    "    hX1, hX2, hX3 = steps\n",
    "    K_mat, Y_mat, L_mat = states\n",
    "    delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, sigma_g, xi_a, xi_k, xi_c, xi_j, xi_d, xi_g, rho, varrho = args\n",
    "\n",
    "    i_star = controls\n",
    "    # First order derivative\n",
    "    dX1 = finiteDiff_3D(v0, 0, 1, hX1)\n",
    "    dX1[dX1 <= 1e-16] = 1e-16\n",
    "    dK = dX1\n",
    "    dX2 = finiteDiff_3D(v0, 1, 1, hX2)\n",
    "    dY = dX2\n",
    "    dX3 = finiteDiff_3D(v0, 2, 1, hX3)\n",
    "    dX3[dX3 <= 1e-16] = 1e-16\n",
    "    dL = dX3\n",
    "    ######## second order\n",
    "    ddX1 = finiteDiff_3D(v0, 0, 2, hX1)\n",
    "    ddX2 = finiteDiff_3D(v0, 1, 2, hX2)\n",
    "    ddY = ddX2\n",
    "    ddX3 = finiteDiff_3D(v0, 2, 2, hX3)\n",
    "\n",
    "    temp = delta * ((alpha - i_star))**(-rho)\n",
    "\n",
    "    i_new = (1 - temp/dK)/kappa\n",
    "\n",
    "    ii = i_new * fraction + i_star * (1 - fraction)\n",
    "\n",
    "    h_k = -1/xi_k * sigma_k * dK\n",
    "\n",
    "    h_k[h_k >= -1e-16] = -1e-16\n",
    "\n",
    "    consumption = alpha - ii\n",
    "    consumption[consumption <= 1e-16] = 1e-16\n",
    "\n",
    "    temp_recursive = (consumption * np.exp(K_mat)/np.exp(v0))**(1-rho) - 1\n",
    "\n",
    "\n",
    "    B_1 = mu_k + ii - 0.5 * kappa * ii**2 - 0.5 * sigma_k**2\n",
    "    B_1 += sigma_k*h_k\n",
    "    B_2 = np.zeros_like(K_mat)\n",
    "    B_3 = np.zeros_like(K_mat)\n",
    "\n",
    "    C_1 = 0.5 * sigma_k**2 * np.ones(K_mat.shape)\n",
    "    C_2 = np.zeros_like(K_mat)\n",
    "    C_3 = np.zeros_like(K_mat)\n",
    "\n",
    "    if rho==1:\n",
    "        A = -delta * np.ones_like(K_mat)\n",
    "        D = delta * np.log(consumption) + delta * K_mat\n",
    "    else:\n",
    "        A = np.zeros_like(K_mat)\n",
    "        D = delta / (1-rho) * temp_recursive\n",
    "        \n",
    "    D += 1/2 * xi_k * h_k**2\n",
    "\n",
    "    return A, B_1, B_2, B_3, C_1, C_2, C_3, D, dX1, ddX1, ii, h_k\n",
    "\n",
    "\n",
    "def hjb_post_tech(\n",
    "        state_grid=(), model_args=(), V_post_damage=None,\n",
    "        tol=1e-8, epsilon=0.1, fraction=0.5, max_iter=10000,\n",
    "        v0=None,\n",
    "        smart_guess=None,\n",
    "):\n",
    "\n",
    "    now = datetime.now()\n",
    "    current_time = now.strftime(\"%d-%H:%M\")\n",
    "    K, Y, L = state_grid\n",
    "\n",
    "    delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, sigma_g, gamma_1, gamma_2, gamma_3, y_bar, xi_a, xi_k, xi_c, xi_j, xi_d, xi_g, rho, varrho = model_args\n",
    "\n",
    "    X1 = K\n",
    "    nX1 = len(X1)\n",
    "    hX1 = X1[1] - X1[0]\n",
    "    X1_min = X1.min()\n",
    "    X1_max = X1.max()\n",
    "    X2 = Y\n",
    "    nX2 = len(X2)\n",
    "    hX2 = X2[1] - X2[0]\n",
    "    X2_min = X2.min()\n",
    "    X2_max = X2.max()\n",
    "    X3 = L\n",
    "    nX3 = len(X3)\n",
    "    hX3 = X3[1] - X3[0]\n",
    "    X3_min = X3.min()\n",
    "    X3_max = X3.max()\n",
    "\n",
    "    print(\"Grid dimension: [{}, {}, {}]\\n\".format(nX1, nX2, nX3))\n",
    "    print(\"Grid step: [{}, {}, {}]\\n\".format(hX1, hX2, hX3))\n",
    "    # Discretization of the state space for numerical PDE solution.\n",
    "    ######## post jump, 3 states\n",
    "    (X1_mat, X2_mat, X3_mat) = np.meshgrid(X1, X2, X3, indexing='ij')\n",
    "    stateSpace = np.hstack([X1_mat.reshape(-1, 1, order='F'),\n",
    "                           X2_mat.reshape(-1, 1, order='F'), X3_mat.reshape(-1, 1, order='F')])\n",
    "    K_mat = X1_mat\n",
    "    Y_mat = X2_mat\n",
    "    L_mat = X3_mat\n",
    "    # For PETSc\n",
    "    X1_mat_1d = X1_mat.ravel(order='F')\n",
    "    X2_mat_1d = X2_mat.ravel(order='F')\n",
    "    X3_mat_1d = X3_mat.ravel(order='F')\n",
    "    lowerLims = np.array([X1_min, X2_min, X3_min], dtype=np.float64)\n",
    "    upperLims = np.array([X1_max, X2_max, X3_max], dtype=np.float64)\n",
    "    #### Model type\n",
    "\n",
    "    # Initial setup of HJB\n",
    "    FC_Err = 1\n",
    "    epoch = 0\n",
    "\n",
    "    if v0 is None:\n",
    "        # v0 = K_mat + L_mat - np.average(pi_c_o, axis=0) * Y_mat\n",
    "        v0 = K_mat\n",
    "\n",
    "    i_star = np.zeros(K_mat.shape)\n",
    "\n",
    "    if smart_guess:\n",
    "        v0 = smart_guess[\"v0\"]\n",
    "        i_star = smart_guess[\"i_star\"]\n",
    "\n",
    "    dVec = np.array([hX1, hX2, hX3])\n",
    "    increVec = np.array([1, nX1, nX1 * nX2], dtype=np.int32)\n",
    "\n",
    "    # FOC_args = (delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, psi_2, sigma_g, V_post_tech, dG, ddG, xi_a, xi_g )\n",
    "\n",
    "    petsc_mat = PETSc.Mat().create()\n",
    "    petsc_mat.setType('aij')\n",
    "    petsc_mat.setSizes([nX1 * nX2 * nX3, nX1 * nX2 * nX3])\n",
    "    petsc_mat.setPreallocationNNZ(13)\n",
    "    petsc_mat.setUp()\n",
    "    ksp = PETSc.KSP()\n",
    "    ksp.create(PETSc.COMM_WORLD)\n",
    "    ksp.setType('bcgs')\n",
    "    ksp.getPC().setType('ilu')\n",
    "    ksp.setFromOptions()\n",
    "\n",
    "    # Enter the optimization\n",
    "    while FC_Err > tol and epoch < max_iter:\n",
    "\n",
    "        FOC_args = (delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o,\n",
    "                    pi_c, sigma_y, zeta, psi_0, psi_1, sigma_g, xi_a, xi_k, xi_c, xi_j, xi_d, xi_g, rho, varrho)\n",
    "\n",
    "        start_ep = time.time()\n",
    "        A, B_1, B_2, B_3, C_1, C_2, C_3, D, dX1, ddX1, ii, h_k = _FOC_update(v0, steps=(\n",
    "            hX1, hX2, hX3), states=(K_mat, Y_mat, L_mat), args=FOC_args, controls=(i_star), fraction=fraction)\n",
    "\n",
    "        out_comp, end_ksp, bpoint1 = pde_one_interation(\n",
    "            ksp,\n",
    "            petsc_mat, X1_mat_1d, X2_mat_1d, X3_mat_1d,\n",
    "            lowerLims, upperLims, dVec, increVec,\n",
    "            v0, A, B_1, B_2, B_3, C_1, C_2, C_3, D, 1e-13, epsilon)\n",
    "        # if epoch % 1 == 0 and reporterror:\n",
    "        # Calculating PDE error and False Transient error\n",
    "\n",
    "        PDE_rhs = A * v0 + B_1 * dX1 + C_1 * ddX1 + D\n",
    "        PDE_Err = np.max(abs(PDE_rhs))\n",
    "        FC_Err = np.max(abs((out_comp - v0) / epsilon))\n",
    "\n",
    "        if FC_Err < 1.2*tol:\n",
    "\n",
    "            if epoch % 100 == 0:\n",
    "                print(\"-----------------------------------\")\n",
    "                print(\"---------Epoch {}---------------\".format(epoch))\n",
    "                print(\"-----------------------------------\")\n",
    "                print(\"min i: {},\\t max i: {}\\t\".format(ii.min(), ii.max()))\n",
    "                # print(\"min e: {},\\t max e: {}\\t\".format(ee.min(), ee.max()))\n",
    "                # print(\"min x: {},\\t max x: {}\\t\".format(xx.min(), xx.max()))\n",
    "                # print(\"min h: {},\\t max h: {}\\t\".format(h.min(), h.max()))\n",
    "                print(\"min hk: {},\\t max hk: {}\\t\".format(h_k.min(), h_k.max()))\n",
    "                # print(\"min hj: {},\\t max hj: {}\\t\".format(h_j.min(), h_j.max()))\n",
    "                print(\"petsc total: {:.3f}s, Residual Norm is {:g}\".format(\n",
    "                    (end_ksp - bpoint1), ksp.getResidualNorm()))\n",
    "                print(\"Epoch {:d} (PETSc): PDE Error: {:.10f}; False Transient Error: {:.10f}\" .format(\n",
    "                    epoch, PDE_Err, FC_Err))\n",
    "                print(\"Epoch time: {:.4f}\".format(time.time() - start_ep))\n",
    "        elif epoch % 10000 == 0:\n",
    "\n",
    "            print(\"-----------------------------------\")\n",
    "            print(\"---------Epoch {}---------------\".format(epoch))\n",
    "            print(\"-----------------------------------\")\n",
    "            print(\"min i: {},\\t max i: {}\\t\".format(ii.min(), ii.max()))\n",
    "            # print(\"min e: {},\\t max e: {}\\t\".format(ee.min(), ee.max()))\n",
    "            # print(\"min x: {},\\t max x: {}\\t\".format(xx.min(), xx.max()))\n",
    "            # print(\"min h: {},\\t max h: {}\\t\".format(h.min(), h.max()))\n",
    "            print(\"min hk: {},\\t max hk: {}\\t\".format(h_k.min(), h_k.max()))\n",
    "            # print(\"min hj: {},\\t max hj: {}\\t\".format(h_j.min(), h_j.max()))\n",
    "            print(\"petsc total: {:.3f}s, Residual Norm is {:g}\".format(\n",
    "                (end_ksp - bpoint1), ksp.getResidualNorm()))\n",
    "            print(\"Epoch {:d} (PETSc): PDE Error: {:.10f}; False Transient Error: {:.10f}\" .format(\n",
    "                epoch, PDE_Err, FC_Err))\n",
    "            print(\"Epoch time: {:.4f}\".format(time.time() - start_ep))\n",
    "\n",
    "        v0 = out_comp\n",
    "        i_star = ii\n",
    "        # e_star = ee\n",
    "        # x_star = xx\n",
    "        epoch += 1\n",
    "\n",
    "    dX1 = finiteDiff_3D(v0, 0, 1, hX1)\n",
    "    dX1[dX1 <= 1e-16] = 1e-16\n",
    "    dK = dX1\n",
    "    ######## second order\n",
    "    ddX1 = finiteDiff_3D(v0, 0, 2, hX1)\n",
    "\n",
    "    res = {\n",
    "        \"v0\": v0,\n",
    "        \"i_star\": i_star,\n",
    "        \"h_k\": h_k,\n",
    "        \"FC_Err\": FC_Err,\n",
    "    }\n",
    "\n",
    "    return res\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## PreSolver.py\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "solver.py\n",
    "For 3D abatement solver\n",
    "\"\"\"\n",
    "import os\n",
    "import sys\n",
    "sys.path.append(\"../../src/\")\n",
    "from src.Utility import finiteDiff_3D\n",
    "import SolveLinSys\n",
    "import numpy as np\n",
    "import petsc4py\n",
    "from petsc4py import PETSc\n",
    "import petsclinearsystem\n",
    "import time\n",
    "from datetime import datetime\n",
    "\n",
    "\n",
    "def pde_one_interation(ksp, petsc_mat, X1_mat_1d, X2_mat_1d, X3_mat_1d, lowerLims, upperLims, dVec, increVec, v0, A, B_1, B_2, B_3, C_1, C_2, C_3, D, tol, epsilon):\n",
    "\n",
    "    bpoint1 = time.time()\n",
    "    A_1d   = A.ravel(order = 'F')\n",
    "    C_1_1d = C_1.ravel(order = 'F')\n",
    "    C_2_1d = C_2.ravel(order = 'F')\n",
    "    C_3_1d = C_3.ravel(order = 'F')\n",
    "    B_1_1d = B_1.ravel(order = 'F')\n",
    "    B_2_1d = B_2.ravel(order = 'F')\n",
    "    B_3_1d = B_3.ravel(order = 'F')\n",
    "    D_1d   = D.ravel(order = 'F')\n",
    "    v0_1d  = v0.ravel(order = 'F')\n",
    "    petsclinearsystem.formLinearSystem(X1_mat_1d, X2_mat_1d, X3_mat_1d, A_1d, B_1_1d, B_2_1d, B_3_1d, C_1_1d, C_2_1d, C_3_1d, epsilon, lowerLims, upperLims, dVec, increVec, petsc_mat)\n",
    "    b = v0_1d + D_1d * epsilon\n",
    "    petsc_rhs = PETSc.Vec().createWithArray(b)\n",
    "    x = petsc_mat.createVecRight()\n",
    "\n",
    "\n",
    "    # create linear solver\n",
    "    start_ksp = time.time()\n",
    "    ksp.setOperators(petsc_mat)\n",
    "    ksp.setTolerances(rtol=tol)\n",
    "    ksp.solve(petsc_rhs, x)\n",
    "    petsc_rhs.destroy()\n",
    "    x.destroy()\n",
    "    out_comp = np.array(ksp.getSolution()).reshape(A.shape,order = \"F\")\n",
    "    end_ksp = time.time()\n",
    "    num_iter = ksp.getIterationNumber()\n",
    "    # print(\"PETSc preconditioned residual norm is {:g}; iterations: {}\".format(ksp.getResidualNorm(), ksp.getIterationNumber()))\n",
    "    return out_comp,end_ksp,bpoint1\n",
    "\n",
    "def _FOC_update(v0, steps= (), states = (), args=(), controls=(), fraction=0.5):\n",
    "\n",
    "    hX1, hX2, hX3 = steps\n",
    "    K_mat, Y_mat, L_mat = states\n",
    "    delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, sigma_g, V_post_tech, dG, ddG, xi_a, xi_k, xi_c, xi_j, xi_d, xi_g, rho, varrho = args\n",
    "\n",
    "    i_star, e_star, x_star = controls\n",
    "    # First order derivative\n",
    "    dX1  = finiteDiff_3D(v0,0,1,hX1)\n",
    "    dX1[dX1 <= 1e-16] = 1e-16\n",
    "    dK = dX1\n",
    "    dX2  = finiteDiff_3D(v0,1,1,hX2)\n",
    "    dY = dX2\n",
    "    dX3  = finiteDiff_3D(v0,2,1,hX3)\n",
    "    dX3[dX3 <= 1e-16] = 1e-16\n",
    "    dL = dX3\n",
    "    ######## second order\n",
    "    ddX1 = finiteDiff_3D(v0,0,2,hX1)\n",
    "    ddX2 = finiteDiff_3D(v0,1,2,hX2)\n",
    "    ddY = ddX2\n",
    "    ddX3 = finiteDiff_3D(v0,2,2,hX3)\n",
    "\n",
    "     # updating controls\n",
    "    if theta == 2 and psi_1 == 1:\n",
    "        mc = dL * psi_1 * psi_0 * np.exp(K_mat - L_mat)\n",
    "        temp2 = theta * vartheta_bar / lambda_bar * np.exp(- K_mat)\n",
    "        F = dY  - dGamma\n",
    "        G = ddY - ddGamma\n",
    "        Omega_1 = mc * temp2 + F * beta_f\n",
    "        Omega_2 = mc * temp2 / (alpha * lambda_bar * np.exp(K_mat)) - F * sigma_y**2\n",
    "        e_new =  Omega_1 / Omega_2\n",
    "        # e_new[e_new <= 1e-15] = 1e-15\n",
    "        i_new = (1 - mc / dK) / kappa\n",
    "        # i_new[i_new <= 1e-15] = 1e-15\n",
    "        temp3 = alpha  - ii - alpha * vartheta_bar * (1 - ee / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "        x_new = temp3 * np.exp(K_mat - L_mat) - 1 / (dL * psi_0 * psi_1)\n",
    "        # x_new[x_new <= 1e-15] = 1e-15\n",
    "    elif theta == 3 and psi_1 == 1:\n",
    "\n",
    "        G = dY  - dG\n",
    "        F = ddY - ddG\n",
    "        mc = dL * psi_1 * psi_0 * np.exp(K_mat - L_mat)\n",
    "        mc[mc <= 1e-16] = 1e-16\n",
    "        temp = mc * vartheta_bar * theta / (lambda_bar * np.exp(K_mat))\n",
    "        a = temp / (alpha * lambda_bar * np.exp(K_mat)) ** (theta - 1)\n",
    "        b = - 2 * temp / (alpha * lambda_bar * np.exp(K_mat)) + F * sigma_y ** 2\n",
    "        c = temp + G * np.sum(theta_ell * pi_c, axis=0)\n",
    "        temp = b ** 2 - 4 * a * c\n",
    "        temp[temp <=0] = 0\n",
    "        # temp = temp * (temp > 0)\n",
    "        root1 = (- b - np.sqrt(temp)) / (2 * a)\n",
    "        root2 = (- b + np.sqrt(temp)) / (2 * a)\n",
    "        if root1.all() > 0 :\n",
    "            e_new = root1\n",
    "        else:\n",
    "            e_new = root2\n",
    "\n",
    "        i_new = (1 - mc/ dK) / kappa\n",
    "        j_star = alpha * vartheta_bar * (1 - e_star / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "        j_star[j_star <= 1e-16] = 1e-16\n",
    "        temp3 = alpha - i_star - j_star\n",
    "        x_new = temp3 - delta / mc\n",
    "\n",
    "    elif psi_1 != 1 and vartheta_bar != 0 and theta == 3:\n",
    "        G = dY -  dG\n",
    "        F = ddY - ddG\n",
    "        \n",
    "        \n",
    "        \n",
    "        # j_star = alpha * vartheta_bar * (1 - e_star / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "        # j_star[j_star <= 1e-16] = 1e-16\n",
    "        # consumption = alpha - i_star - j_star - x_star\n",
    "        # consumption[consumption <= 1e-16] = 1e-16\n",
    "        # mc  = delta / consumption\n",
    "        # temp = mc * vartheta_bar * theta / (lambda_bar * np.exp(K_mat))\n",
    "        \n",
    "        j_star = alpha * vartheta_bar * (1 - e_star / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "        j_star[j_star <= 1e-16] = 1e-16\n",
    "        consumption = alpha - i_star - j_star - x_star\n",
    "        consumption[consumption <= 1e-16] = 1e-16\n",
    "        \n",
    "        # temp_insiderho = consumption * np.exp(K_mat)/np.exp(v0)\n",
    "        temp_mc =  delta * (consumption * np.exp(K_mat)/np.exp(v0))**(-rho)\n",
    "        \n",
    "        \n",
    "        temp_e_coef = temp_mc * vartheta_bar * theta/ ( lambda_bar * np.exp(v0) )\n",
    "        \n",
    "        \n",
    "        # a = temp / (alpha * lambda_bar * np.exp(K_mat))**(theta - 1)\n",
    "        # b = - 2 * temp / (alpha * lambda_bar * np.exp(K_mat)) +  F * sigma_y**2 - G**2 * sigma_y**2/xi_c\n",
    "        # c = temp + G * np.sum(theta_ell * pi_c, axis=0)\n",
    "        \n",
    "        a = temp_e_coef / (alpha * lambda_bar * np.exp(K_mat))**(theta - 1)\n",
    "        b = - 2 * temp_e_coef / (alpha * lambda_bar * np.exp(K_mat)) +  F * sigma_y**2 - G**2 * sigma_y**2/xi_c\n",
    "        c = temp_e_coef + G * np.sum(theta_ell * pi_c, axis=0)\n",
    "        \n",
    "        \n",
    "        temp = b ** 2 - 4 * a * c\n",
    "        temp = temp * (temp > 0)\n",
    "        root1 = (- b - np.sqrt(temp)) / (2 * a)\n",
    "        root2 = (- b + np.sqrt(temp)) / (2 * a)\n",
    "        if root1.all() > 0 :\n",
    "            # print(\"use root1\")\n",
    "            e_new = root1\n",
    "        else:\n",
    "            # print(\"use root2\")\n",
    "            e_new = root2\n",
    "\n",
    "        e_new[e_new <= 1e-16] = 1e-16\n",
    "        \n",
    "        # newly added\n",
    "        \n",
    "        \n",
    "        temp_ix_coef = temp_mc * np.exp(K_mat)/np.exp(v0)\n",
    "        \n",
    "        # temp_i_coef = temp_mc * np.exp(K_mat)/np.exp(v0)\n",
    "        \n",
    "        i_new = - (temp_ix_coef / dK - 1) / kappa\n",
    "        i_new[i_new <= 1e-16] = 1e-16\n",
    "        \n",
    "\n",
    "\n",
    "        # temp_x_coef = temp_mc * np.exp(K_mat)/np.exp(v0)\n",
    "\n",
    "        x_new = (temp_ix_coef / (dL * psi_0 * psi_1) * np.exp(psi_1 * (L_mat - K_mat)) )**(1 / (psi_1 - 1))\n",
    "\n",
    "    ee = e_new * fraction + e_star * (1 - fraction)\n",
    "    ii = i_new * fraction + i_star * (1 - fraction)\n",
    "    xx = x_new * fraction + x_star * (1 - fraction)\n",
    "\n",
    "    # update smooth ambiguity\n",
    "    pi_c = pi_c_o\n",
    "    \n",
    "    # entropy = np.sum(pi_c * (np.log(pi_c) - np.log(pi_c_o)), axis=0)\n",
    "    entropy = np.zeros_like(K_mat)\n",
    "    \n",
    "    \n",
    "    # Technology\n",
    "    gg = np.exp(1 / xi_g * (v0 - V_post_tech))\n",
    "    gg[gg <=1e-16] = 1e-16\n",
    "    \n",
    "    # Climate \n",
    "    \n",
    "    h = - 1/ xi_c * sigma_y * ee * G\n",
    "    \n",
    "    h[h<=1e-16] = 1e-16\n",
    "    h[h>=1] = 1\n",
    "    \n",
    "    \n",
    "    h_k = -1/xi_k *sigma_k * dK \n",
    "    h_j = -1/xi_j *sigma_g * dL \n",
    "    \n",
    "    h_k[h_k>=-1e-16]=-1e-16\n",
    "    h_j[h_j>=-1e-16]=-1e-16\n",
    "    \n",
    "    \n",
    "    jj =  alpha * vartheta_bar * (1 - ee / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "    jj[jj <= 1e-16] = 1e-16\n",
    "    \n",
    "    consumption = alpha - ii - jj - xx\n",
    "    consumption[consumption <= 1e-16] = 1e-16\n",
    "    \n",
    "    temp_recursive = (consumption *np.exp(K_mat)/np.exp(v0))**(1-rho) - 1\n",
    "    \n",
    "\n",
    "    \n",
    "    B_1 = mu_k + ii - 0.5 * kappa * ii**2 - 0.5 * sigma_k**2\n",
    "    B_1 += sigma_k*h_k\n",
    "    \n",
    "    B_2 = np.sum(theta_ell * pi_c, axis=0) * ee\n",
    "    B_2 += sigma_y * h * ee\n",
    "    \n",
    "    B_3 = - zeta + psi_0 * (xx * np.exp(K_mat - L_mat))**psi_1 - 0.5 * sigma_g**2\n",
    "    B_3 += sigma_g*h_j\n",
    "    \n",
    "\n",
    "    C_1 = 0.5 * sigma_k**2 * np.ones(K_mat.shape)\n",
    "    C_2 = 0.5 * sigma_y**2 * ee**2\n",
    "    C_3 = 0.5 * sigma_g**2 * np.ones(K_mat.shape)\n",
    "\n",
    "    if rho ==1:\n",
    "        A   = - delta * np.ones(K_mat.shape)- np.exp(  L_mat - np.log(varrho) ) * gg\n",
    "        D = delta * np.log(consumption) + delta * K_mat\n",
    "    else:\n",
    "        A   = - np.exp(  L_mat - np.log(varrho) ) * gg\n",
    "        D = delta / (1-rho) *temp_recursive\n",
    "     \n",
    "    D += - dG * (np.sum(theta_ell * pi_c, axis=0) + sigma_y * h) * ee  - 0.5 * ddG * sigma_y**2 * ee**2  \n",
    "    D += xi_a * entropy \n",
    "    D += xi_g * np.exp((L_mat - np.log(varrho))) * (1 - gg + gg * np.log(gg)) + np.exp( (L_mat - np.log(varrho)) ) * gg * V_post_tech\n",
    "    \n",
    "    D += 1/2 * xi_c * h**2\n",
    "    D += 1/2 * xi_k * h_k**2\n",
    "    D += 1/2 * xi_j * h_j**2\n",
    "    \n",
    "    \n",
    "    return A, B_1, B_2, B_3, C_1, C_2, C_3, D, dX1, dX2, dX3, ddX1, ddX2, ddX3, ii, ee, xx, pi_c, gg, h, h_k, h_j\n",
    "\n",
    "\n",
    "def hjb_pre_tech(\n",
    "        state_grid=(), model_args=(), V_post_damage=None, \n",
    "        tol=1e-8, epsilon=0.1, fraction=0.5, max_iter=10000,\n",
    "        v0=None,\n",
    "        smart_guess=None,\n",
    "        ):\n",
    "\n",
    "    now = datetime.now()\n",
    "    current_time = now.strftime(\"%d-%H:%M\")\n",
    "    K, Y, L = state_grid\n",
    "\n",
    "    delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, sigma_g, V_post_tech, gamma_1, gamma_2, gamma_3, y_bar, xi_a, xi_k, xi_c, xi_j, xi_d, xi_g, rho, varrho = model_args\n",
    "\n",
    "\n",
    "    X1     = K\n",
    "    nX1    = len(X1)\n",
    "    hX1    = X1[1] - X1[0]\n",
    "    X1_min = X1.min()\n",
    "    X1_max = X1.max()\n",
    "    X2     = Y\n",
    "    nX2    = len(X2)\n",
    "    hX2    = X2[1] - X2[0]\n",
    "    X2_min = X2.min()\n",
    "    X2_max = X2.max()\n",
    "    X3     = L\n",
    "    nX3    = len(X3)\n",
    "    hX3    = X3[1] - X3[0]\n",
    "    X3_min = X3.min()\n",
    "    X3_max = X3.max()\n",
    "\n",
    "    filename =  \"post_damage_\" + str(gamma_3)  + '_{}'.format(current_time)\n",
    "    print(\"Grid dimension: [{}, {}, {}]\\n\".format(nX1, nX2, nX3))\n",
    "    print(\"Grid step: [{}, {}, {}]\\n\".format(hX1, hX2, hX3))\n",
    "    # Discretization of the state space for numerical PDE solution.\n",
    "    ######## post jump, 3 states\n",
    "    (X1_mat, X2_mat, X3_mat) = np.meshgrid(X1, X2, X3, indexing = 'ij')\n",
    "    stateSpace = np.hstack([X1_mat.reshape(-1,1,order = 'F'), X2_mat.reshape(-1,1,order = 'F'), X3_mat.reshape(-1, 1, order='F')])\n",
    "    K_mat = X1_mat\n",
    "    Y_mat = X2_mat\n",
    "    L_mat = X3_mat\n",
    "    # For PETSc\n",
    "    X1_mat_1d = X1_mat.ravel(order='F')\n",
    "    X2_mat_1d = X2_mat.ravel(order='F')\n",
    "    X3_mat_1d = X3_mat.ravel(order='F')\n",
    "    lowerLims = np.array([X1_min, X2_min, X3_min], dtype=np.float64)\n",
    "    upperLims = np.array([X1_max, X2_max, X3_max], dtype=np.float64)\n",
    "    #### Model type\n",
    "    if isinstance(gamma_3, (np.ndarray, list)):\n",
    "        model = \"Pre damage\"\n",
    "        pi_d_o = np.ones(len(gamma_3)) / len(gamma_3)\n",
    "        pi_d_o = np.array([temp * np.ones(K_mat.shape) for temp in pi_d_o ])\n",
    "        y_bar_lower = 1.5\n",
    "        r_1 = 1.5\n",
    "        r_2 = 2.5\n",
    "        Intensity = r_1 * (np.exp(r_2 / 2 * (Y_mat - y_bar_lower)**2) -1) * (Y_mat > y_bar_lower)\n",
    "        v_i = V_post_damage\n",
    "        dG  = gamma_1 + gamma_2 * Y_mat\n",
    "        ddG = gamma_2 \n",
    "    else:\n",
    "        model = \"Post damage\"\n",
    "        # dG  = gamma_1 + gamma_2 * Y_mat + gamma_3 * (Y_mat - y_bar) * (Y_mat >= y_bar)\n",
    "        # ddG = gamma_2 + gamma_3 * (Y_mat >= y_bar)\n",
    "        dG  = gamma_1 + gamma_2 * Y_mat + gamma_3 * (Y_mat - y_bar) \n",
    "        ddG = gamma_2 + gamma_3 \n",
    "    # Initial setup of HJB\n",
    "    FC_Err   = 1\n",
    "    epoch    = 0\n",
    "\n",
    "    if v0 is None:\n",
    "        v0 = K_mat + L_mat - np.average(pi_c_o, axis=0) * Y_mat\n",
    "\n",
    "    i_star = np.zeros(K_mat.shape)\n",
    "    e_star = np.ones(K_mat.shape)\n",
    "    # e_star = np.zeros(K_mat.shape)\n",
    "    x_star = np.zeros(K_mat.shape)\n",
    "    \n",
    "    if smart_guess:\n",
    "        v0     = smart_guess[\"v0\"]\n",
    "        i_star = smart_guess[\"i_star\"]\n",
    "        e_star = smart_guess[\"e_star\"]\n",
    "        x_star = smart_guess[\"x_star\"]\n",
    "        pi_c = smart_guess['pi_c']\n",
    "        g_tech = smart_guess['g_tech']\n",
    "        if model == \"Pre damage\":\n",
    "            g_damage = smart_guess['g_damage']\n",
    "            \n",
    "    \n",
    "\n",
    "    dVec = np.array([hX1, hX2, hX3])\n",
    "    increVec = np.array([1, nX1, nX1 * nX2],dtype=np.int32)\n",
    "\n",
    "    # FOC_args = (delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, psi_2, sigma_g, V_post_tech, dG, ddG, xi_a, xi_g )\n",
    "\n",
    "    petsc_mat = PETSc.Mat().create()\n",
    "    petsc_mat.setType('aij')\n",
    "    petsc_mat.setSizes([nX1 * nX2 * nX3, nX1 * nX2 * nX3])\n",
    "    petsc_mat.setPreallocationNNZ(13)\n",
    "    petsc_mat.setUp()\n",
    "    ksp = PETSc.KSP()\n",
    "    ksp.create(PETSc.COMM_WORLD)\n",
    "    ksp.setType('bcgs')\n",
    "    ksp.getPC().setType('ilu')\n",
    "    ksp.setFromOptions()\n",
    "\n",
    "    # Enter the optimization\n",
    "    while FC_Err > tol and epoch < max_iter:\n",
    "        \n",
    "        FOC_args = (delta, alpha, theta, vartheta_bar, lambda_bar, mu_k, kappa, sigma_k, theta_ell, pi_c_o, pi_c, sigma_y, zeta, psi_0, psi_1, sigma_g, V_post_tech, dG, ddG, xi_a, xi_k, xi_c, xi_j, xi_d, xi_g, rho, varrho)\n",
    "\n",
    "        start_ep = time.time()\n",
    "        A, B_1, B_2, B_3, C_1, C_2, C_3, D, dX1, dX2, dX3, ddX1, ddX2, ddX3, ii, ee, xx, pi_c, g_tech, h, h_k, h_j = _FOC_update(v0, steps= (hX1, hX2, hX3), states = (K_mat, Y_mat, L_mat), args=FOC_args, controls=(i_star, e_star, x_star), fraction=fraction)\n",
    "\n",
    "        if model == \"Pre damage\":\n",
    "            g_damage = np.exp(- (v_i-v0)/xi_d)\n",
    "\n",
    "            D += xi_d * Intensity * np.sum( pi_d_o*(1-g_damage+g_damage*np.log(g_damage)),axis=0) +Intensity*np.sum(pi_d_o*g_damage*v_i,axis=0)\n",
    "            A -=  Intensity*np.sum(pi_d_o*g_damage,axis=0)\n",
    "\n",
    "        jj =  alpha * vartheta_bar * (1 - ee / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "        \n",
    "        consumption = alpha - ii - jj - xx\n",
    "        \n",
    "        out_comp,end_ksp, bpoint1 = pde_one_interation(\n",
    "                ksp,\n",
    "                petsc_mat,X1_mat_1d, X2_mat_1d, X3_mat_1d, \n",
    "                lowerLims, upperLims, dVec, increVec,\n",
    "                v0, A, B_1, B_2, B_3, C_1, C_2, C_3, D, 1e-13, epsilon)\n",
    "        # if epoch % 1 == 0 and reporterror:\n",
    "            # Calculating PDE error and False Transient error\n",
    "        \n",
    "        PDE_rhs = A * v0 + B_1 * dX1 + B_2 * dX2 + B_3 * dX3 + C_1 * ddX1 + C_2 * ddX2 + C_3 * ddX3 + D\n",
    "        PDE_Err = np.max(abs(PDE_rhs))\n",
    "        FC_Err = np.max(abs((out_comp - v0)/ epsilon))\n",
    "        \n",
    "        if FC_Err < 1.2*tol:\n",
    "            \n",
    "            if epoch%100==0:\n",
    "                print(\"-----------------------------------\")\n",
    "                print(\"---------Epoch {}---------------\".format(epoch))\n",
    "                print(\"-----------------------------------\")\n",
    "                print(\"min i: {},\\t max i: {}\\t\".format(ii.min(), ii.max()))\n",
    "                print(\"min e: {},\\t max e: {}\\t\".format(ee.min(), ee.max()))\n",
    "                print(\"min x: {},\\t max x: {}\\t\".format(xx.min(), xx.max()))\n",
    "                print(\"min cons: {},\\t max cons: {}\\t\".format(consumption.min(), consumption.max()))\n",
    "                print(\"min h: {},\\t max h: {}\\t\".format(h.min(), h.max()))\n",
    "                print(\"min hk: {},\\t max hk: {}\\t\".format(h_k.min(), h_k.max()))\n",
    "                print(\"min hj: {},\\t max hj: {}\\t\".format(h_j.min(), h_j.max()))\n",
    "                print(\"petsc total: {:.3f}s, Residual Norm is {:g}\".format((end_ksp - bpoint1),ksp.getResidualNorm()))\n",
    "                print(\"Epoch {:d} (PETSc): PDE Error: {:.10f}; False Transient Error: {:.10f}\" .format(epoch, PDE_Err, FC_Err))\n",
    "                print(\"Epoch time: {:.4f}\".format(time.time() - start_ep))\n",
    "        elif epoch%1000==0:\n",
    "            \n",
    "            print(\"-----------------------------------\")\n",
    "            print(\"---------Epoch {}---------------\".format(epoch))\n",
    "            print(\"-----------------------------------\")\n",
    "            print(\"min i: {},\\t max i: {}\\t\".format(ii.min(), ii.max()))\n",
    "            print(\"min e: {},\\t max e: {}\\t\".format(ee.min(), ee.max()))\n",
    "            print(\"min x: {},\\t max x: {}\\t\".format(xx.min(), xx.max()))\n",
    "            print(\"min cons: {},\\t max cons: {}\\t\".format(consumption.min(), consumption.max()))\n",
    "            print(\"min h: {},\\t max h: {}\\t\".format(h.min(), h.max()))\n",
    "            print(\"min hk: {},\\t max hk: {}\\t\".format(h_k.min(), h_k.max()))\n",
    "            print(\"min hj: {},\\t max hj: {}\\t\".format(h_j.min(), h_j.max()))\n",
    "            print(\"petsc total: {:.3f}s, Residual Norm is {:g}\".format((end_ksp - bpoint1),ksp.getResidualNorm()))\n",
    "            print(\"Epoch {:d} (PETSc): PDE Error: {:.10f}; False Transient Error: {:.10f}\" .format(epoch, PDE_Err, FC_Err))\n",
    "            print(\"Epoch time: {:.4f}\".format(time.time() - start_ep))\n",
    "        \n",
    "\n",
    "        v0     = out_comp\n",
    "        i_star = ii\n",
    "        e_star = ee\n",
    "        x_star = xx\n",
    "        epoch += 1\n",
    "\n",
    "    dX1  = finiteDiff_3D(v0,0,1,hX1)\n",
    "    dX1[dX1 <= 1e-16] = 1e-16\n",
    "    dK = dX1\n",
    "    dX2  = finiteDiff_3D(v0,1,1,hX2)\n",
    "    dY = dX2\n",
    "    dX3  = finiteDiff_3D(v0,2,1,hX3)\n",
    "    dX3[dX3 <= 1e-16] = 1e-16\n",
    "    dL = dX3\n",
    "    ######## second order\n",
    "    ddX1 = finiteDiff_3D(v0,0,2,hX1)\n",
    "    ddX2 = finiteDiff_3D(v0,1,2,hX2)\n",
    "    ddY = ddX2\n",
    "    ddX3 = finiteDiff_3D(v0,2,2,hX3)\n",
    "    \n",
    "    G = dY -  dG\n",
    "    F = ddY - ddG\n",
    "    j_star = alpha * vartheta_bar * (1 - e_star / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "    j_star[j_star <= 1e-16] = 1e-16\n",
    "    consumption = alpha - i_star - j_star - x_star\n",
    "    consumption[consumption <= 1e-16] = 1e-16\n",
    "    mc  = delta / consumption\n",
    "    temp = mc * vartheta_bar * theta / (lambda_bar * np.exp(K_mat))\n",
    "    a = temp / (alpha * lambda_bar * np.exp(K_mat))**(theta - 1)\n",
    "    b = - 2 * temp / (alpha * lambda_bar * np.exp(K_mat)) +  F * sigma_y**2\n",
    "    c = temp + G * np.sum(theta_ell * pi_c, axis=0)\n",
    "    temp = b ** 2 - 4 * a * c\n",
    "    temp = temp * (temp > 0)\n",
    "    root1 = (- b - np.sqrt(temp)) / (2 * a)\n",
    "    root2 = (- b + np.sqrt(temp)) / (2 * a)\n",
    "    if root1.all() > 0 :\n",
    "        # print(\"use root1\")\n",
    "        e_new = root1\n",
    "    else:\n",
    "        # print(\"use root2\")\n",
    "        e_new = root2\n",
    "        \n",
    "        \n",
    "    print(\"e_new=[{},{}]\".format(e_new.min(),e_new.max()))    \n",
    "    \n",
    "    ME = - dX2 * np.sum(pi_c * theta_ell, axis=0) - ddX2 * sigma_y**2 * ee + dG * np.sum(theta_ell * pi_c, axis=0) +  ddG * sigma_y**2 * ee\n",
    "    jj = alpha * vartheta_bar * (1 - ee / (alpha * lambda_bar * np.exp(K_mat)))**theta\n",
    "    \n",
    "    jj[jj <= 1e-16] = 1e-16\n",
    "    consumption = alpha - ii - jj - xx\n",
    "    ME_total = delta/ consumption  * alpha * vartheta_bar * theta * (1 - ee / ( alpha * lambda_bar * np.exp(K_mat)))**(theta - 1) /( alpha * lambda_bar * np.exp(K_mat) )\n",
    "\n",
    "    dvdY = finiteDiff_3D(v0,1,1,hX2)\n",
    "    \n",
    "    print(\"log(ME_total/ME) = [{},{}]\".format(np.min(np.log(ME_total / ME)), np.max(np.log(ME_total / ME))))\n",
    "    print(\"dvdY=[{},{}]\".format(dvdY.min(),dvdY.max()))\n",
    "    \n",
    "    res = {\n",
    "            \"v0\"    : v0,\n",
    "            \"i_star\": i_star,\n",
    "            \"e_star\": e_star,\n",
    "            \"e_orig\": e_new,\n",
    "            \"x_star\": x_star,\n",
    "            \"pi_c\"  : pi_c,\n",
    "            \"g_tech\": g_tech,\n",
    "            \"h\": h,\n",
    "            \"h_k\": h_k,\n",
    "            \"h_j\": h_j,\n",
    "            \"ME\": ME,\n",
    "            \"FC_Err\": FC_Err,\n",
    "            }\n",
    "    if model == \"Pre damage\":\n",
    "        res = {\n",
    "                \"v0\"    : v0,\n",
    "                \"i_star\": i_star,\n",
    "                \"e_star\": e_star,\n",
    "                \"e_orig\": e_new,\n",
    "                \"x_star\": x_star,\n",
    "                \"pi_c\"  : pi_c,\n",
    "                \"g_tech\": g_tech,\n",
    "                \"h\": h,\n",
    "                \"h_k\": h_k,\n",
    "                \"h_j\": h_j,\n",
    "                \"ME\": ME,\n",
    "                \"g_damage\": g_damage,\n",
    "                \"FC_Err\": FC_Err,\n",
    "                }\n",
    "    return res"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
